---
id: monorepo
title: Monorepo Starter (Turborepo + pnpm)
description: Scaffold a production-ready monorepo with Turborepo, pnpm workspaces, shared configs, and a Next.js app.
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Overview

The Monorepo Starter scaffolds a Turborepo + pnpm workspaces setup with:

- apps/web â†’ Next.js frontend
- packages/components â†’ UI component library (with design tokens)
- packages/config â†’ shared configs (ESLint, TypeScript, Tailwind)
- Root `tsconfig.json`, `turbo.json`, `pnpm-workspace.yaml`
- Caching and parallelization via Turborepo

## Installation Methods

<Tabs groupId="package-manager">
  <TabItem value="npm" label="npm" default>

  ```bash
  npm install -g @mindfiredigital/ignix-cli
  ```

  </TabItem>
  <TabItem value="yarn" label="Yarn">

  ```bash
  yarn global add @mindfiredigital/ignix-cli
  ```

  </TabItem>
  <TabItem value="npx" label="npx">

  ```bash
  npx @mindfiredigital/ignix-cli
  ```

  </TabItem>
</Tabs>

## Usage Modes

### Generate via CLI

<Tabs>
  
  <TabItem value="interactive" label="Interactive">

### Via Interactive Mode

Simply run `ignix` without any arguments to enter interactive mode:

```bash
ignix
```

The interactive mode provides a beautiful, guided interface with the following options:
- ðŸš€ **Initialize Ignix UI** - Set up your project
- âž• **Add components** - Add components to your project
- ðŸ“‹ **List components** - View available components
- ðŸŽ¨ **Manage themes** - Configure and manage themes
- ðŸ“¦ **Starters Template** - Generate a new starter template
- ðŸšª **Exit** - Close the CLI

Choose the option **Starters Template** and press Enter.
<div className="border border-gray-300 rounded-lg inline-block p-2">
![Ignix CLI](/img/ignix-cli.png)
</div>
<br />
Then select **Monorepo (Turborepo + pnpm)** from the list of available starters.
<br />
<div className="border border-gray-300 rounded-lg inline-block p-2">
![Ignix CLI Monorepo](/img/ignix-cli-monorepo.png)
</div>
</TabItem>
<TabItem value="direct" label="Direct">

Run the starter command directly:

```bash
ignix monorepo
```

  </TabItem>
</Tabs>

This will:
- Create the monorepo structure
- Write shared configs
- Wire workspace dependencies
- Optionally install dependencies (if enabled in your CLI)

## Generated Structure

```text
.
â”œâ”€ apps/
â”‚  â””â”€ web/                  # Next.js app
â”‚     â”œâ”€ app/page.tsx
â”‚     â”œâ”€ package.json
â”‚     â”œâ”€ next.config.mjs
â”‚     â””â”€ tsconfig.json
â”œâ”€ packages/
â”‚  â”œâ”€ components/           # UI library
â”‚  â”‚  â”œâ”€ src/
â”‚  â”‚  â”‚  â”œâ”€ Button.tsx
â”‚  â”‚  â”‚  â”œâ”€ tokens.ts
â”‚  â”‚  â”‚  â””â”€ index.ts
â”‚  â”‚  â”œâ”€ package.json
â”‚  â”‚  â”œâ”€ tsconfig.json
â”‚  â”‚  â””â”€ tsconfig.build.json
â”‚  â””â”€ config/               # Shared configs
â”‚     â”œâ”€ eslint/index.cjs
â”‚     â”œâ”€ tailwind/tailwind.config.cjs
â”‚     â”œâ”€ tsconfig/base.json
â”‚     â””â”€ package.json
â”œâ”€ package.json             # Workspaces + Turbo scripts
â”œâ”€ pnpm-workspace.yaml
â”œâ”€ turbo.json               # Turborepo pipeline and caching
â””â”€ tsconfig.json            # Shared base
```

## Workspace Scripts

From the repository root:

- `pnpm dev`: run all dev servers (Turborepo orchestrated)
- `pnpm build`: build all packages/apps with incremental caching
- `pnpm lint`: run linters across the repo

## Sharing Components across Apps

The Next.js app consumes the shared UI library:

```tsx
// apps/web/app/page.tsx
import { Button } from '@acme/components/src';

export default function Page() {
  return (
    <main style={{ padding: 24 }}>
      <h1>Ignix Monorepo</h1>
      <Button>From components pkg</Button>
    </main>
  );
}
```

Development flow:
1. Edit components in `packages/components/src/*`
2. In another terminal, run `pnpm dev` at the root to rebuild and run apps
3. Turborepo caches and only rebuilds what changed

## Turborepo Caching

The `turbo.json` config enables:
- Task graph with `dependsOn` to reuse upstream builds
- Output tracking for cache hits
- Persistent `dev` tasks

Builds are significantly faster on subsequent runs or when only a subset of packages change.



